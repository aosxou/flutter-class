========================================
## 은행 계좌 클래스 (BankAccount)
========================================

```dart
class BankAccount {
  // private 변수: 외부에서 직접 접근 불가
  double _balance;

  // 생성자
  BankAccount(this._balance);

  // getter: 잔액 조회 (읽기 전용)
  double get balance => _balance;

  // 입금 메서드
  void deposit(double amount) {
    if (amount > 0) {
      _balance += amount;
      print('Deposited: \$${amount.toStringAsFixed(2)}');
    } else {
      print('Invalid deposit amount');
    }
  }

  // 출금 메서드
  void withdraw(double amount) {
    if (amount > 0 && amount <= _balance) {
      _balance -= amount;
      print('Withdrawn: \$${amount.toStringAsFixed(2)}');
    } else {
      print('Invalid withdrawal amount');
    }
  }
}

void main1() {
  var account = BankAccount(1000.0);

  print('Current Balance: \$${account.balance}');
  account.deposit(500.0);
  account.withdraw(200.0);
  print('Final Balance: \$${account.balance}');
}
```

### 결과 예시
Current Balance: $1000.00
Deposited: $500.00
Withdrawn: $200.00
Final Balance: $1300.00


========================================
## 부모-자식 클래스 예시 (Animal & Dog)
========================================
```dart

// 부모 클래스
class Animal {
  String name;

  Animal(this.name);

  void speak() {
    print('$name makes a sound.');
  }
}

// 자식 클래스
class Dog extends Animal {
  Dog(String name) : super(name); // 부모 생성자 호출

  // 메서드 오버라이딩
  @override
  void speak() {
    print('$name barks.');
  }

  void fetch() {
    print('$name is fetching the ball!');
  }
}

void main2() {
  Animal genericAnimal = Animal('Creature');
  genericAnimal.speak(); // Creature makes a sound.

  Dog myDog = Dog('Buddy');
  myDog.speak();         // Buddy barks.
  myDog.fetch();         // Buddy is fetching the ball!
}
```

### 결과 예시
Creature makes a sound.
Buddy barks.
Buddy is fetching the ball!


========================================
## 다형성 예시 (Animal, Cat, Dog, Duck)
========================================
```dart

class Animal2 {
  String name;

  Animal2(this.name);

  void makeSound() {
    print("$name이(가) 소리를 냅니다.");
  }
}

class Cat extends Animal2 {
  Cat(String name) : super(name);

  @override
  void makeSound() {
    print("$name: 냐옹");
  }
}

class Dog2 extends Animal2 {
  Dog2(String name) : super(name);

  @override
  void makeSound() {
    print("$name: 멍멍");
  }
}

class Duck extends Animal2 {
  Duck(String name) : super(name);

  @override
  void makeSound() {
    print("$name: 꽥꽥");
  }
}

void main3() {
  List<Animal2> animals = [
    Cat("냐옹이"),
    Cat("검정 고양이"),
    Dog2("강아지"),
    Dog2("아기 강아지"),
    Duck("오리"),
    Duck("오리아이1"),
    Duck("오리아이2"),
  ];

  for (var animal in animals) {
    animal.makeSound();
  }
}
```

### 결과 예시
냐옹이: 냐옹
검정 고양이: 냐옹
강아지: 멍멍
아기 강아지: 멍멍
오리: 꽥꽥
오리아이1: 꽥꽥
오리아이2: 꽥꽥

========================================
## 기본 버전 (단일 Animal 클래스)
========================================

```dart
class Animal3 {
  String name;

  Animal3(this.name);

  void makeSound() {
    print("$name이(가) 소리를 냅니다.");
  }
}

void main4() {
  Animal3 a1 = Animal3("고양이");
  Animal3 a2 = Animal3("강아지");

  a1.makeSound();
  a2.makeSound();

  List<Animal3> animals = [a1, a2];
  for (var i = 0; i < animals.length; i++) {
    animals[i].makeSound();
  }
}

```

### 결과 예시
고양이이(가) 소리를 냅니다.
강아지이(가) 소리를 냅니다.
고양이이(가) 소리를 냅니다.
강아지이(가) 소리를 냅니다.


========================================
객체지향 프로그래밍(OOP)의 4가지 특징
========================================

1️⃣ **캡슐화 (Encapsulation)**
   - 데이터(변수)와 메서드(기능)를 하나의 객체 안에 묶는 개념.
   - 접근 제어자를 통해 외부에서 직접 접근을 제한하고,
     필요한 경우에만 메서드로 접근하도록 함.
   - 예: BankAccount 클래스의 `_balance`는 private 변수로 외부에서 직접 수정 불가.

2️⃣ **상속 (Inheritance)**
   - 기존 클래스의 속성과 기능을 물려받아 새로운 클래스를 정의하는 것.
   - 코드 재사용성을 높이고, 구조를 단순화시킴.
   - 예: `Dog` 클래스가 `Animal` 클래스를 상속받음.

3️⃣ **다형성 (Polymorphism)**
   - 같은 부모 타입을 참조하더라도 실제 객체의 타입에 따라
     다른 동작을 수행할 수 있는 성질.
   - 예: `List<Animal>` 안의 `Cat`, `Dog`, `Duck` 객체들이
     각각 다른 방식으로 `makeSound()` 실행.

4️⃣ **추상화 (Abstraction)**
   - 불필요한 세부 사항은 감추고, 꼭 필요한 정보와 기능만 공개하는 것.
   - 공통된 기능을 추상 클래스나 인터페이스로 정의하여
     여러 클래스에서 재사용 가능.
   - Dart에서는 `abstract class`로 선언 가능.

----------------------------------------
특징별 장단점 요약표
----------------------------------------

| 특징 | 장점 | 단점 |
|------|------|------|
| **캡슐화** | 데이터 보호, 코드 안정성 향상 | 접근 제어 설계가 복잡할 수 있음 |
| **상속** | 코드 재사용성 증가, 유지보수 용이 | 다중 상속 불가(Dart), 부모 의존성 증가 |
| **다형성** | 유연한 코드, 확장성 향상 | 디버깅 어려움, 설계 난이도 상승 |
| **추상화** | 구조적 설계 가능, 핵심 기능에 집중 | 구현 클래스 작성 시 추가 작업 필요 |

----------------------------------------
✅ 정리
- 객체지향의 핵심은 **현실 세계를 코드로 표현**하는 것.
- “캡슐화 → 상속 → 다형성 → 추상화”는 서로 연계되어 작동하며,
  잘 설계된 OOP는 유지보수성과 확장성을 극대화한다.