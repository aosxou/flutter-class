# 오늘 배운 내용 (2025-09-22)

## 1. 학습 목표
- Dart의 기본 문법과 제어문을 복습
- Flutter 아키텍처와 위젯 구조 이해
- Container 및 기본 UI 레이아웃 구현


## 지난 주차 배운 내용 복습

### 1-1. print문 기본 출력

```dart
void main() {
  print('Hello, Dart!'); 
} 
```

### 1-2. 변수 사용하여 출력

```dart
void main() {
  var name;
  name = '이가윤';
  
  print('Hello, ' +name+'!');
} 
```

### 1-3. 문자열 보간

```dart
void main() {
  var name;
  name = '이가윤';
  
  print('Hello, $name!');
} 
```

### 2-1. for문 이용하여 이름 뒤에 숫자 붙이기

```dart
void main() 
{
  var name;
  name = '이가윤';
  for (var i = 1; i <= 10; i++) {
    print('내 이름은 $name 입니다 $i.');
  }
}
```
### 2-2. for문과 if문을 이용, 짝수만 출력

```dart
void main() 
{
  var name;
  name = '이가윤';
  for (var i = 1; i <= 10; i++) {
    if (i%2 == 0) {
    print('내 이름은 $name 입니다 $i.');
    }  
    }
}  
```
### 2-2. for문과 if문을 이용, 짝수만 출력 (함수)

```dart
void main() 
{
  var name;
  name = '이가윤';
  
  func(name, 10);
}  

void func(String name, int count) {
  for (var i = 1; i <=count; i++) {
    if (i%2 == 0) {
      print("내 이름은 $name 입니다 $i.");
    }
  }
}
```

## 1. Flutter 아키텍처

| 계층 (Layer) | 구성 요소 | 역할 | 주요 기술 / 언어 |
|-------------|-----------|------|-------------------|
| **Embedder (임베더)** | 플랫폼별 Embedder (Android, iOS, Windows 등) | - 플랫폼 환경 설정 및 초기화<br>- Flutter 엔진 구동<br>- 입력 이벤트(터치/키보드), 창(Window) 관리<br>- 플랫폼 채널 초기화 | 플랫폼별 네이티브 언어 (Java/Kotlin, Objective-C/Swift, C++) |
| **Engine (엔진)** | Flutter Engine + Skia | - 렌더링 파이프라인 구성<br>- 텍스트/이미지 처리<br>- Dart VM 실행 환경 제공<br>- GPU와 통신 및 저수준 그래픽 처리 | C/C++, Skia Graphics, Dart VM |
| **Framework (프레임워크)** | Widget / Rendering / Painting / Animation | - Dart로 작성된 UI 프레임워크<br>- 선언형 UI, 상태관리, 라우팅<br>- Widget → Element → RenderObject 계층 구조 제공 | Dart |

**요약:**  
플러터는 `임베더 → 엔진 → 프레임워크` 순서로 구성되며,  
앱 개발자는 주로 **프레임워크 계층(Dart)** 을 사용해서 앱을 작성.

---

## 2. 앱 아키텍처 (3계층 구조)

| 계층 | 이름 | 역할 | 주요 구성 요소 / 예시 |
|------|------|------|-------------------------|
| **프레젠테이션 계층** | Presentation Layer | - 사용자 인터페이스(UI) 표현<br>- 사용자 입력 처리<br>- 상태(ViewModel) 반영 | Flutter Widgets, View, UI, Provider/Bloc ViewModel |
| **비즈니스 논리 계층** | Business / Domain Layer | - 앱의 핵심 로직 처리<br>- 상태 관리 및 규칙 적용<br>- 프레젠테이션-데이터 계층 연결 | BLoC, UseCase, Service, Controller, Riverpod StateNotifier |
| **데이터 계층** | Data Layer | - 외부 데이터 소스와의 통신<br>- Repository 패턴으로 추상화<br>- API, DB, 캐시 관리 | REST API, Firebase, SQLite, Hive, Repository |

**흐름 요약:**  
사용자 입력 (UI) → 비즈니스 로직 처리 (BLoC/UseCase) → 데이터 요청 (Repository) →  
응답 결과를 UI에 반영 → 화면 갱신.

---

## 3. Widget 계층 구조 (추가)

| 단계 | 이름 | 설명 |
|------|------|------|
| **Widget** | 불변(Immutable) 선언형 객체, “무엇을 그릴지” 정의 |
| **Element** | Widget의 인스턴스화된 표현 (위젯 트리와 렌더 트리를 연결) |
| **RenderObject** | 실제 레이아웃, 페인트, 히트테스트 등을 담당하는 렌더링 객체 |

즉, 화면에 그릴 때는  
`Widget → Element → RenderObject`  
순서로 실제 UI가 구성되고 그려짐.

---

## 2. Flutter 구조 (상위 레벨)
- **Embedder (임베더)**
  - 플랫폼(예: Android/iOS/Windows/macOS/Linux)별로 Flutter 엔진을 실행시키는 코드.
  - 플랫폼 창(window), 이벤트(터치·키보드), 스레드 관리, 텍스트 입력, 플랫폼 채널 초기화 등을 담당.
  - 각 플랫폼의 네이티브 런타임과 통신하는 역할을 함.

- **Engine (엔진)**
  - 주로 C/C++로 구현 (Skia 렌더러 포함).
  - **렌더링 파이프라인**(Skia), 텍스트 레이아웃, 이미지 디코딩, Dart VM/Runtime 연동, 플랫폼 채널 통신, 그리고 GPU/그래픽스 인터페이스를 담당.
  - 프레임을 구성하고 GPU로 넘기는 저수준 작업 수행.

- **Framework (프레임워크)**
  - Dart로 작성된 계층. 앱 개발자가 직접 사용하는 API (widgets, rendering, painting, animation 등).
  - 위젯(Widgets), 요소(Element), 렌더 오브젝트(RenderObject)로 구성된 UI 계층 모델 제공.
  - 상태관리, 라우팅, 레이아웃, 테마 등을 구현.

---

## 3. 아키텍처 관점: 계층별 역할

### 3-1. 프레젠테이션 계층 (Presentation Layer)
- UI와 직접 상호작용하는 부분.
- Flutter에서는 대부분 **Widget**이 프레젠테이션 계층 역할을 수행.
- 사용자 입력 처리, 화면에 보이는 뷰, 뷰 모델(혹은 컨트롤러) 연동 담당.
- 책임: 화면 구성, 사용자 인터페이스 표시 및 사용성.

### 3-2. 비즈니스 논리 계층 / 도메인 계층 (Business / Domain Layer)
- 앱의 핵심 규칙과 상태(비즈니스 로직)를 담당.
- 예: 유효성 검사, 상태 변화 규칙, 도메인 서비스, 유스케이스(interactors).
- 프레젠테이션과 데이터 계층 사이의 중개자 역할.
- Flutter에서 흔히 BLoC, Provider, Riverpod, GetX 등으로 표현.

### 3-3. 데이터 계층 (Data Layer)
- 외부 데이터 소스와의 통신(네트워크, 로컬 DB, 캐시 등).
- Repository 패턴으로 추상화하여 비즈니스 계층에 노출.
- 책임: API 호출, 데이터 매핑, 영속화, 캐싱 전략.

---

## 4. 계층 간의 흐름 (간단 예시)
1. 사용자가 버튼을 누름 (Presentation)
2. 버튼 이벤트가 ViewModel/BLoC로 전달되어 유스케이스를 호출 (Business)
3. 유스케이스는 Repository에 데이터 요청 (Data)
4. Repository가 네트워크 호출 → 응답을 도메인 모델로 변환 → 유스케이스에 반환
5. 유스케이스가 결과를 가공하여 ViewModel에 전달 → UI 갱신 (Presentation)

---

## 5. 위젯(Widget)의 정의
- **위젯**은 Flutter UI의 기본 빌딩 블록(불변의 선언형 객체).
- 위젯은 **상태가 없는 위젯(StatelessWidget)** 과 **상태가 있는 위젯(StatefulWidget)** 으로 구분.
  - **StatelessWidget**: 내부 상태가 없고, 주어진 입력(properties)에 의해 동일한 UI 반환.
  - **StatefulWidget**: 내부 상태(State)를 가지며, 상태 변화에 따라 UI를 재구성함.
- 위젯은 실제로 **렌더링을 직접 수행하지 않음**. 위젯 → Element → RenderObject 의 순으로 변환되어 레이아웃/페인트 단계가 이뤄짐.
- 위젯의 책임: *어떻게 보일지 선언* (what to display). 실제 화면에 그리는 것은 렌더 계층의 책임.

---

## 6. 간단한 위젯 예제 (Dart)
```dart
import 'package:flutter/material.dart';

class MyCounter extends StatefulWidget {
  const MyCounter({Key? key}) : super(key: key);

  @override
  State<MyCounter> createState() => _MyCounterState();
}

class _MyCounterState extends State<MyCounter> {
  int _count = 0;

  void _increment() {
    setState(() => _count += 1);
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Count: $_count'),
        ElevatedButton(onPressed: _increment, child: const Text('Increment')),
      ],
    );
  }
}
```

## 7. 참고 용어 정리

- Embedder: 플랫폼-엔진 연결자
- Engine: 렌더링/그래픽스/VM 연동(C++ 레이어)
- Framework: Dart로 구현된 UI/Widget 계층
- Widget → Element → RenderObject: Flutter UI 변환 단계

## StatefulWidget 라이프사이클

===========================================
StatefulWidget Life Cycle 요약 표
===========================================

┌────┬───────────────────────────────┬─────────────────────────────────────┐
│ 순서 │ 메서드 이름                   │ 설명                                 │
├────┼───────────────────────────────┼─────────────────────────────────────┤
│ 1  │ Constructor (Widget)          │ 위젯 객체 생성                        │
│ 2  │ createState()                 │ State 객체 생성                      │
│ 3  │ initState()                   │ State 초기화 (1회만)                  │
│ 4  │ didChangeDependencies()       │ 의존성 변경 시 호출 (초기 1회 포함)     │
│ 5  │ build()                       │ UI 생성 및 갱신                       │
│ 6  │ didUpdateWidget()             │ 부모 위젯이 새로운 데이터 전달 시        │
│ 7  │ deactivate()                  │ 위젯이 트리에서 제거되기 직전            │
│ 8  │ dispose()                     │ State 객체가 완전히 제거될 때           │
└────┴───────────────────────────────┴─────────────────────────────────────┘

## 9. 레이아웃 구성을 위한 위젯

### 9-1. 다양한 container 옵션을 사용한 예시

```dart

import 'package:flutter/material.dart';     
// Flutter의 기본 Material 디자인 라이브러리를 불러옴

void main() {
  runApp(const MyApp());                     
  // 앱 시작점(main 함수). runApp()이 위젯 트리를 화면에 띄움
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});                  
  // MyApp 클래스의 생성자 (StatelessWidget, 변경 불가한 위젯)

  @override
  Widget build(BuildContext context) {
    // MyApp이 실제로 화면에 그릴 UI를 정의
    return MaterialApp(
      title: 'Flutter Demo',                 
      // 앱의 제목(일부 플랫폼에서 사용됨)
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        // 전체 앱의 색상 테마 설정. seedColor를 기반으로 색 조합 자동 생성
      ),
      home: const MyHomePage(title: '플러터 데모 홈페이지'),
      // 앱이 처음 실행될 때 표시할 첫 화면을 설정
    );
  }
}

class MyHomePage extends StatefulWidget {
  // 상태(State)를 가지는 위젯 정의
  const MyHomePage({super.key, required this.title});
  final String title;                        
  // 상단 AppBar에 표시할 문자열

  @override
  State<MyHomePage> createState() => _MyHomePageState();
  // 이 StatefulWidget과 연결된 State 객체 생성
}

class _MyHomePageState extends State<MyHomePage> {
  // MyHomePage의 상태를 관리하는 클래스
  int _counter = 0;                           
  // 상태 값 (버튼 누른 횟수)

  void _incrementCounter() {
    setState(() {
      _counter++;
    });
    // setState로 상태값을 변경하면 build()가 다시 호출되어 UI가 갱신됨
  }

  @override
  Widget build(BuildContext context) {
    // 화면이 그려질 때마다 실행되는 메서드
    return Scaffold(
      // 기본적인 앱 레이아웃 구조 제공 (AppBar, Body, FAB 등)
      appBar: AppBar(
        backgroundColor: Theme.of(context).colorScheme.inversePrimary,
        // 앱바의 배경색 설정 (테마 색 반전)
        title: Text(widget.title),
        // 상단에 전달받은 제목 표시
      ),
      body: Center(
        // 화면의 중앙에 child를 배치하는 위젯
        child: buildbody2(),
        // 아래 정의된 buildbody2() 위젯을 중앙에 표시
      ),
      floatingActionButton: FloatingActionButton(
        // 화면 우하단에 표시되는 +버튼(둥둥 떠있는 버튼)
        onPressed: _incrementCounter,
        // 버튼을 눌렀을 때 실행할 함수
        tooltip: '증가',
        // 버튼 길게 눌렀을 때 나오는 툴팁
        child: const Icon(Icons.ads_click),
        // 버튼 안에 표시할 아이콘
      ), 
    );
  }

  Widget buildbody() {
    // 예제 1: 파란색 Container를 중앙에 표시하는 함수
    return Center(
      child : Container(
        padding: const EdgeInsets.only(left:20, right:20),
        // 컨테이너 내부 좌우 여백
        width: 200,
        height: 50,
        color: Colors.blue,
        child: Center(child: Text('Container')),
        // 가운데 "Container" 텍스트 표시
      ),
    );
  }

  Widget buildbody2() {
    // 예제 2: 그라디언트+그림자+둥근 모서리가 있는 박스를 중앙에 표시
    return Container(
      padding: const EdgeInsets.only(left:20, right:20),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          // Container의 배경을 그라디언트로 설정
          colors: [
            Color.fromARGB(255, 255, 59, 98).withOpacity(0.7),
            Color.fromARGB(255, 255, 59, 98)
          ],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(10),
        // 모서리를 10px 둥글게
        boxShadow: [
          BoxShadow(
            color: Color.fromARGB(255, 255, 59, 98).withOpacity(0.3),
            spreadRadius: 5,
            blurRadius: 7,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      width: 200,
      height: 150,
      child : Center(
        child: Text(
          'Container',
          style: TextStyle(color: Colors.white),
        ),
      ),
    );
  }
}
```

### 9-2. Container 옵션

- 1. padding : Container 내부 여백 조절
- 2. width : Container 너비 설정
- 3. height : Container 높이 설정
- 4. color : Container 배경색 설정
- 5. child : Container 내부에 들어갈 다른 위젯 설정 (모든 위젯에 자식 위젯 지정 가능)
- decoration : 그라데이션, 그림자 효과, 모서리 둥글게 설정 등등 -> 고급스러운 UI 구성